# Rust + Go Integration Guide

This document explains how the Rust FFI library integrates with the Go application.

## Architecture Overview

```
┌─────────────────────────────────────────────┐
│          Go Application Layer               │
│  ┌──────────────────────────────────────┐  │
│  │     CLI Interface (cmd/app)          │  │
│  │     Web Server (internal/handler)    │  │
│  └──────────────────────────────────────┘  │
│                    ▼                         │
│  ┌──────────────────────────────────────┐  │
│  │  Service Layer (internal/service)    │  │
│  │  - Templates                          │  │
│  │  - Business Logic                     │  │
│  └──────────────────────────────────────┘  │
│                    ▼                         │
│  ┌──────────────────────────────────────┐  │
│  │   FFI Bindings (internal/ffi)        │  │
│  │   - Go wrapper functions             │  │
│  │   - CGO integration                   │  │
│  └──────────────────────────────────────┘  │
└─────────────────────────────────────────────┘
                     ▼
         ┌─────────────────────┐
         │   C FFI Interface   │
         └─────────────────────┘
                     ▼
┌─────────────────────────────────────────────┐
│          Rust Library Layer                 │
│  ┌──────────────────────────────────────┐  │
│  │  FFI Exports (rust_ffi/crates/core)  │  │
│  │  - C-compatible functions            │  │
│  └──────────────────────────────────────┘  │
│                    ▼                         │
│  ┌──────────────────────────────────────┐  │
│  │  Operations (operations/)            │  │
│  │  - Create, Delete, Copy, Move        │  │
│  │  - Permissions, Rename               │  │
│  └──────────────────────────────────────┘  │
│                    ▼                         │
│  ┌──────────────────────────────────────┐  │
│  │  Common (common/)                    │  │
│  │  - Error handling                     │  │
│  │  - Shared types                       │  │
│  └──────────────────────────────────────┘  │
└─────────────────────────────────────────────┘
```

## Build Process

### 1. Rust Library Build

```bash
cd rust_ffi
cargo build --release -p fs-operations-core
```

**Output:**
- Linux: `rust_ffi/target/release/libfs_operations_core.so`
- macOS: `rust_ffi/target/release/libfs_operations_core.dylib`
- Windows: `rust_ffi/target/release/fs_operations_core.dll`

### 2. Go Application Build

```bash
CGO_ENABLED=1 \
CGO_LDFLAGS="-L./rust_ffi/target/release -lfs_operations_core -ldl -lpthread -lm" \
go build -o filemanager ./cmd/app
```

**CGO Configuration:**
- `CGO_ENABLED=1` - Enable CGO for FFI
- `CGO_LDFLAGS` - Link to Rust library
- `-L./rust_ffi/target/release` - Library search path
- `-lfs_operations_core` - Link the Rust library
- `-ldl -lpthread -lm` - System dependencies

## Data Flow

### Example: Creating a File

1. **User Input (CLI)**
   ```go
   // cmd/app/main.go
   result := ffi.CreateFile("/tmp/test.txt")
   ```

2. **Go FFI Wrapper**
   ```go
   // internal/ffi/operations.go
   func CreateFile(path string) Result {
       cPath := C.CString(path)
       defer C.free(unsafe.Pointer(cPath))
       
       cResult := C.create_file(cPath)
       return processResult(cResult)
   }
   ```

3. **C FFI Interface**
   ```c
   // Generated by CGO
   OperationResult create_file(const char* path);
   ```

4. **Rust FFI Export**
   ```rust
   // rust_ffi/crates/core/src/ffi/mod.rs
   #[no_mangle]
   pub extern "C" fn create_file(path: *const c_char) -> OperationResult {
       match c_str_to_string(path) {
           Ok(path_str) => match operations::create::create_file(&path_str) {
               Ok(msg) => OperationResult::success(&msg),
               Err(e) => OperationResult::error(&e.to_string()),
           },
           Err(e) => OperationResult::error(&e.to_string()),
       }
   }
   ```

5. **Rust Implementation**
   ```rust
   // rust_ffi/crates/core/src/operations/create.rs
   pub fn create_file(path: &str) -> FsResult<String> {
       fs::File::create(path)?;
       Ok(format!("File created: {}", path))
   }
   ```

## Memory Management

### Rust to Go String Passing

**Problem:** Rust allocates memory, Go needs to read and free it.

**Solution:**
```rust
// Rust allocates
let msg = CString::new("Success").unwrap().into_raw();

// Go reads
message := C.GoString(cResult.message)

// Go tells Rust to free
C.free_result(cResult)

// Rust frees
#[no_mangle]
pub extern "C" fn free_result(result: OperationResult) {
    if !result.message.is_null() {
        unsafe {
            let _ = CString::from_raw(result.message);
        }
    }
}
```

### Go to Rust String Passing

```go
// Go converts to C string
cPath := C.CString("/tmp/file.txt")
defer C.free(unsafe.Pointer(cPath))  // Go frees

// Rust reads (doesn't own)
let c_str = unsafe { CStr::from_ptr(path) };
let path_str = c_str.to_str()?;
```

## Error Handling

### Rust Side

```rust
// Custom error type
#[derive(Error, Debug)]
pub enum FsError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Invalid UTF-8: {0}")]
    InvalidUtf8(String),
}

// Convert to FFI result
match operation() {
    Ok(msg) => OperationResult::success(&msg),
    Err(e) => OperationResult::error(&e.to_string()),
}
```

### Go Side

```go
// Result struct
type Result struct {
    Success bool
    Message string
}

// Check result
result := ffi.CreateFile(path)
if result.Success {
    fmt.Printf("✅ %s\n", result.Message)
} else {
    fmt.Printf("❌ %s\n", result.Message)
}
```

## Platform-Specific Considerations

### Linux
- **Library:** `.so` files
- **Loader:** Uses `LD_LIBRARY_PATH`
- **Installation:** `/usr/local/lib/` + `ldconfig`

### macOS
- **Library:** `.dylib` files
- **Loader:** Uses `DYLD_LIBRARY_PATH`
- **Installation:** `/usr/local/lib/`
- **Note:** May need code signing for distribution

### Windows
- **Library:** `.dll` files
- **Loader:** Uses `PATH`
- **Installation:** Same directory as executable or `C:\Windows\System32`
- **Build:** Requires MinGW-w64 for cross-compilation

## Development Workflow

### 1. Modify Rust Code
```bash
cd rust_ffi/crates/core
# Edit src/operations/create.rs
cargo test  # Run tests
cargo build --release
```

### 2. Rebuild Go Application
```bash
cd ../../../
make go  # Rebuilds with new Rust library
```

### 3. Test Integration
```bash
make run
# or
make test
```

## Debugging

### Enable Rust Debug Symbols
```bash
cd rust_ffi
cargo build  # Debug build in target/debug/
```

### Build Go with Debug Symbols
```bash
CGO_LDFLAGS="-L./rust_ffi/target/debug -lfs_operations_core" \
go build -gcflags="all=-N -l" -o filemanager ./cmd/app
```

### Check Library Dependencies
```bash
# Linux
ldd filemanager

# macOS
otool -L filemanager

# Windows
dumpbin /dependents filemanager.exe
```

### Runtime Library Path
```bash
# Linux
export LD_LIBRARY_PATH=$PWD/rust_ffi/target/release:$LD_LIBRARY_PATH

# macOS
export DYLD_LIBRARY_PATH=$PWD/rust_ffi/target/release:$DYLD_LIBRARY_PATH

# Windows
set PATH=%CD%\rust_ffi\target\release;%PATH%
```

## Performance Considerations

### Advantages
- **Zero-copy strings:** Rust passes pointers to Go
- **No serialization:** Direct memory access via FFI
- **Compiled code:** Both Rust and Go are compiled to native code
- **Minimal overhead:** C FFI is the thinnest possible abstraction

### Optimization Tips
1. **Batch operations:** Group multiple calls to reduce FFI overhead
2. **Reuse strings:** Cache frequently-used paths
3. **Release builds:** Always use `--release` for Rust
4. **Static linking:** Consider static linking for deployment

## Troubleshooting

### "Library not found" Error
```bash
# Check library location
ls rust_ffi/target/release/libfs_operations_core.*

# Add to library path
export LD_LIBRARY_PATH=$PWD/rust_ffi/target/release:$LD_LIBRARY_PATH
```

### "Undefined symbol" Error
```bash
# Rebuild Rust library
cd rust_ffi
cargo clean
cargo build --release

# Rebuild Go application
cd ..
make clean
make all
```

### CGO Compilation Errors
```bash
# Ensure CGO is enabled
export CGO_ENABLED=1

# Check C compiler
which gcc
gcc --version

# On Windows, ensure MinGW-w64 is installed
x86_64-w64-mingw32-gcc --version
```

## Best Practices

1. **Always free FFI results:** Use `defer C.free_result()` in Go
2. **Validate input:** Check for null/empty strings before FFI calls
3. **Handle errors:** Never ignore FFI result status
4. **Test both layers:** Write tests for Rust and Go separately
5. **Document changes:** Update both README files when modifying FFI interface
6. **Version lock:** Use specific Rust and Go versions for consistency
7. **CI/CD:** Test cross-compilation on all platforms

## Future Improvements

- [ ] Add async FFI support for long-running operations
- [ ] Implement progress callbacks for large file operations
- [ ] Add batch operation APIs to reduce FFI overhead
- [ ] Create language bindings for Python, Node.js
- [ ] Add performance benchmarks
- [ ] Implement zero-copy buffer sharing for large files